Pn[9,8]<-lambda98/lambda90*(1-Pn[9,9])
Pn[9,10]<-lambda910/lambda90*(1-Pn[9,9])
# absorbing states - virus does not leave these states
Pn[5,5]<-1
Pn[6,6]<-1
Pn[7,7]<-1
Pn[8,8]<-1
Pn[10,10]<-1
#############################################################################################################################################
# STAGE 4: DEFINE VIRUS EMISSION CHARACTERISTICS
#############################################################################################################################################
# Pathogens in COUGH particles
if(Ncough!=0){
# number of pathogens in particle bin
n.paths.cough.particle<-matrix(0, nrow=16, ncol=Ncough)
# number of particles
n.cough.particle<-matrix(0, nrow=16, ncol=Ncough)
for (n in 1:Ncough){
for (i in 1:16){
#sample the number of particles in each particle size bin
n.cough.particle[i,n]<-rpois(1,ChaoCough[i,7])
#number of pathogens is the particle size bin is number particles x
#                                             volume of particles x
#                                             volume unit correction (um^3 to cm^3) x
#                                             concentration in saliva x
#                                             concentration adjustment
n.paths.cough.particle[i,n]<-n.cough.particle[i,n]*ChaoCough[i,5]*(10^(-12))*CONCsaliva*Dist.saliva[i]
}
}
#emission rate to air and surfaces (pathogens/minute)
EairCough<-sum(sum(n.paths.cough.particle[1:3,]))/Tmax
EsurfCough<-sum(sum(n.paths.cough.particle[4:16,]))/Tmax
}
if(Ncough==0){
EairCough<-0
EsurfCough<-0
}
# Pathogens in BREATHING/TALKING particles
#continuous emission into air and surfaces in near field (PFU per min)
rateEair<-(EairCough+EairTalk)/gf
rateEsurface<-(EsurfCough)/gf
#continuous emission into air and surfaces in far field (PFU per min)
rateEair2<-((EairCough+EairTalk)*FFinfected)/gf
rateEsurface2<-((EsurfCough)*FFinfected)/gf
#############################################################################################################################################
# STAGE 5: INITIAL COMPARTMENT CONDITIONS - equated with steady state
#############################################################################################################################################
# emission is into the air in the NF and onto surfaces in the NF
Nair<-(rateEair)/(lambda12+lambda17+lambda18+lambda19)
Nsurface<-rateEsurface/(lambda27)
# emission is into the air in the FF and onto surfaces in the FF
Nair2<-(rateEair2)/(lambda93+lambda97+lambda98+lambda91)
Nsurface2<-rateEsurface2/(lambda37)
#############################################################################################################################################
# STAGE 6: TRACK DOSE TO DIFFERENT LOCATIONS
#############################################################################################################################################
trackP<-matrix(0, nrow=(Tmax/dt), ncol=4)
#P[1,6] = NF air to lungs
#P[1,5] = NF air to mucous membranes
#P[2,5] = NF substrates to mucous membranes
#P[1,10] = NF to lower respiratory tract (FF inhalation)
trackP[1,]<-c(P[1,6], P[1,5], P[2,5], P[1,10])
trackFF<-matrix(0, nrow=(Tmax/dt), ncol=4)
#P[9,6] = FF air to lungs
#P[9,5] = FF air to membranes
#P[3,5] = FF substrates to mucous membranes
#P[9,10] = FF air to the lower respriatory tract of worker (inhale in far-field)
trackFF[1,]<-c(P[9,6], P[9,5], P[3,5], P[9,10])
#############################################################################################################################################
# STAGE 7: COMPUTE INHALATION AND CONTACT DOSE
#############################################################################################################################################
# Create the binary variable for which transisition matrix to use in the matrix multiplication
if(FFtime == 100){
choice<-sample(c(0,0,0,0,0,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 90){
choice<-sample(c(1,0,0,0,0,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 80){
choice<-sample(c(1,1,0,0,0,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 70){
choice<-sample(c(1,1,1,0,0,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 60){
choice<-sample(c(1,1,1,1,0,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 50){
choice<-sample(c(1,1,1,1,1,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 40){
choice<-sample(c(1,1,1,1,1,1,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 30){
choice<-sample(c(1,1,1,1,1,1,1,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 20){
choice<-sample(c(1,1,1,1,1,1,1,1,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 10){
choice<-sample(c(1,1,1,1,1,1,1,1,1,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 0){
choice<-sample(c(1,1,1,1,1,1,1,1,1,1),Tmax/dt, replace=TRUE)
}
########################################### VECTORISE? ############################################
# now simulate the Markov chain
Ptemp<-P
# create boolean for choice
condition<-as.logical(choice)
# start from 2 because 1 is the intial concentrations
for (t in 2:(Tmax/dt)){
if (condition[t]){
Ptemp<-Ptemp%*%P
} else{
Ptemp<-Ptemp%*%Pn
}
trackP[t,]<-c(Ptemp[1,6], Ptemp[1,5], Ptemp[2,5],Ptemp[1,10])
trackFF[t,]<-c(Ptemp[9,6], Ptemp[9,5], Ptemp[3,5],Ptemp[9,10])
}
####################################################################################################
nsteps<-length(trackP[,1])
# total dose to the lung is from emission at each time step into near-field air, and surfaces
# plus dose resulting from initial conditions in each of these three zones
doseLUNGi<-sum(trackP[,1]*rateEair*dt)+
trackP[nsteps,1]*Nair
doseLUNGFFi<-sum(trackP[,4]*rateEair*dt)+
trackP[nsteps,4]*Nair
doseFACEi<-sum(trackP[,2]*rateEair*dt)+
sum(trackP[,3]*rateEsurface*dt)+
trackP[nsteps,2]*Nair+
trackP[nsteps,3]*Nsurface
# if there is more than 1 infected in the room then add total dose to the lung is from emission at each time step into far-field air, and surfaces
# plus dose resulting from initial conditions in each of these three zones
if(Infected>1){
doseLUNGi2<-sum(trackFF[,1]*rateEair2*dt)+trackFF[nsteps,1]*Nair2
doseLUNGFFi2<-sum(trackFF[,4]*rateEair2*dt)+trackFF[nsteps,4]*Nair2
doseFACEi2<-sum(trackFF[,2]*rateEair2*dt)+sum(trackFF[,3]*rateEsurface2*dt)+trackFF[nsteps,2]*Nair2+trackFF[nsteps,3]*Nsurface
# combine the dose recieved in the near field and the far field
doseLUNGi<-doseLUNGi+doseLUNGi2
doseLUNGFFi<-doseLUNGFFi + doseLUNGFFi2
doseFACEi<-doseFACEi + doseFACEi2
}
# apply the effect of respirator
doseLUNG<-doseLUNGi*Finhale
doseLUNGFF<-doseLUNGFFi*Finhale
# apply the effect of fomite cleaning
doseFACE<-Ffomite*doseFACEi*(Fspray*pTARGET*(Suface/Aportals)+Feye*pTARGET*(Sueye/Aportals))
#############################################################################################################################################
# STAGE 8: COMPUTE INHALATION AND CONTACT INFECTION RISK
#############################################################################################################################################
#for exponential dose-response model
rFACE<-1-exp(-doseFACE/DRk)
rLUNGNF<-1-exp(-(doseLUNG)/DRk)
rLUNGFF<-1-exp(-(doseLUNGFF)/DRk)
#############################################################################################################################################
# STAGE 9: COMPUTE SPRAY DOSE
#############################################################################################################################################
#fraction of the cone surface area that represents a facial portal/mucous membrane
probthin <- Aportals/(3.8*10^3)
#fraction of the cone volume that is inhaled (0.0005 m^3 per breath, 0.079 m^3 cone volume)
probinsp <- 0.0005/(0.079)
if(Ncough>0){
doseS <-matrix(0, nrow=16, ncol=Ncough)
doseI <-matrix(0, nrow=16, ncol=Ncough)
for (n in 1:Ncough){
for (i in 10:16){
# if there are no particles in the size bin
if (n.cough.particle[i,n] == 0) {
doseS[i,n]<-0
}
# if there are particles in the size bin
if (n.cough.particle[i,n]!=0) {
# number of pathogens in particles that land on face
doseS[i,n]<-n.paths.cough.particle[i,n]*probthin
}
}
# now the spray inhalation
for (i in 1:9){
# if there are no particles in the size bin
if (n.cough.particle[i,n] == 0) {
doseI[i,n]<-0
}
# if there are particles in the size bin
if (n.cough.particle[i,n]!=0) {
# number of pathogens in particles that are inspired
doseI[i,n]<-n.paths.cough.particle[i,n]*probinsp
}
}
}
}
if(Ncough==0){
doseS<-0
doseI<-0}
# apply the exposure reduction from a respirator/surgical mask and eye protection
doseSPRAY<-sum(sum(doseS))*(Fspray*Suface/Aportals+Feye*Sueye/Aportals)
doseINSP<-sum(sum(doseI))*(Finhale)
#############################################################################################################################################
# STAGE 10: COMPUTE SPRAY INFECTION RISK
#############################################################################################################################################
# calculate conditional (on proportion of particles that deposit on the facial mucous membranes which reach receptors in the respiratory tract) probability
CONDPROBINFSPRAY<-1-exp(-((doseSPRAY*pTARGET)*doseINSP)/DRk)
# calculate the unconditional probability (conditional multiplied by probability of HCW intercepting cough)
UNCONDPROBINFSPRAY <- pSPRAY*CONDPROBINFSPRAY
rSPRAY <- 1 - ((1 - UNCONDPROBINFSPRAY)^Ncough)
if(Ncough==0){
doseSPRAY<-0
rSPRAY<-0
}
#############################################################################################################################################
# STAGE 11: COMPUTE OVERALLL INFECTION RISK AND GENERATE OUTPUTS
#############################################################################################################################################
#COMPUTED USING INCLUSION-EXCLUSION FORMULA
rOVERALL<-
rFACE+rLUNGNF+rLUNGFF+rSPRAY-
rFACE*rLUNGNF+rFACE*rLUNGFF+rFACE*rSPRAY+rLUNGNF*rLUNGFF+rLUNGNF*rSPRAY+rLUNGFF*rSPRAY+
rFACE*rLUNGNF*rLUNGFF+rFACE*rLUNGNF*rSPRAY+rFACE*rLUNGFF*rSPRAY+rLUNGNF*rLUNGFF*rSPRAY-
rFACE*rLUNGNF*rLUNGFF*rSPRAY
# calculate how many became infected by multiplying the overall risk by how many are susceptible
numberinfected<-Su*rOVERALL
# combine all the outputs and add them to the original dataframe
result<-cbind(
V,W,Vn,NFsizeperc, betaNF, ACH, pSPRAY, FFtime,
Tmax, Infcoughrateperhour,Ncough, FFinfected, COUGHrate,
CONCsaliva, gf, Infactivity, InfEairTalkS,EairTalkS,InfEairTalkSQA,  INACTIVair,
INACTIVsurface, INACTIVskin, Aportals, TRANSsurface.skin, TRANSskin,
CONTACTsurfaceNF.hand, CONTACTsurfaceFF.hand, CONTACTface.hand, pTARGET,
ExtraExpVolStudy, distsalivavirusconc, Feye, Fspray, Finhale, Ffomite,
rateEair, rateEsurface, rateEair2, rateEsurface2,nsteps,  probthin, probinsp,
Nsurface, Nsurface2, Nair, Nair2, doseFACE, doseLUNG, doseLUNGFF, doseSPRAY,rFACE, rSPRAY, rLUNGNF, rLUNGFF, rOVERALL, numberinfected)
result<-data.frame(result)
return(result)
}
)
CEMRA::run_model("Test", 10)
CEMRA::run_model("Test", 100)
golem::run_dev()
golem::run_dev()
golem::run_dev()
golem::run_dev()
FFtime=60
if(FFtime == 100){
choice<-sample(c(0,0,0,0,0,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 90){
choice<-sample(c(1,0,0,0,0,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 80){
choice<-sample(c(1,1,0,0,0,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 70){
choice<-sample(c(1,1,1,0,0,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 60){
choice<-sample(c(1,1,1,1,0,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 50){
choice<-sample(c(1,1,1,1,1,0,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 40){
choice<-sample(c(1,1,1,1,1,1,0,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 30){
choice<-sample(c(1,1,1,1,1,1,1,0,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 20){
choice<-sample(c(1,1,1,1,1,1,1,1,0,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 10){
choice<-sample(c(1,1,1,1,1,1,1,1,1,0),Tmax/dt, replace=TRUE)
} else if(FFtime == 0){
choice<-sample(c(1,1,1,1,1,1,1,1,1,1),Tmax/dt, replace=TRUE)
}
choice
start.time <- Sys.time()
CEMRA::run_model("Test", 100)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
numCores <- detectCores()
library(foreach)
library(doParallel)
numCores <- detectCores()
num_range()
start.time <- Sys.time()
CEMRA::run_model("Test", 100)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
golem::run_dev()
start.time <- Sys.time()
CEMRA::run_model("Test", 100)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
rm(list = c("run_model"))
start.time <- Sys.time()
CEMRA::run_model("Test", 100)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
run_model("Test", 100)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
golem::run_dev()
start.time <- Sys.time()
run_model("Test", 100)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
registerDoParallel(numCores)
foreach (i=1:3, .combine=rbind) %dopar% {
sqrt(i)
}
func2<-function(input) {
a<-input+1
b<-input+2
output<-list(a=a,b=b)
return(output)
}
output<-func2(5)
for (i in output) {
print(i)
}
func2<-function(input) {
a<-input+1
b<-input+2
return(list(a=a,b=b))
}
output<-func2(5)
output
foreach (i=1:3, .combine=c) %dopar% {
sqrt(i)
}
start.time <- Sys.time()
run_model("Test", 100)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
golem::run_dev()
start.time <- Sys.time()
run_model("Test", 100)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
run_model("Test", 1000)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
foreach (i=1:3, .combine=c) %dopar% {
sqrt(i)
}
stopImplicitCluster()
start.time <- Sys.time()
run_model("Test", 1000)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
close(con)
close(con)
close(con)
stopCluster(cl)
stopCluster(c)
stopCluster()
?registerDoParallel
registerDoParallel(numCores)
stopImplicitCluster()
registerDoParallel(numCores)
cl <- makePSOCKcluster(numCores)
cl
stopImplicitCluster()
stopImplicitCluster()
stopImplicitCluster()
stopImplicitCluster()
stopImplicitCluster()
stopImplicitCluster()
stopImplicitCluster()
registerDoParallel(numCores)
library(foreach)
foreach(i = 1:3) %do% {
sqrt(i)
}
cl <- parallel::makeCluster(2)
doParallel::registerDoParallel(cl)
foreach(i = 1:3, .combine = 'c') %dopar% {
sqrt(i)
}
cl
golem::run_dev()
start.time <- Sys.time()
run_model("Test", 1000)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
warnings()
start.time <- Sys.time()
run_model("Test", 10000)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
run_model("Test", 10)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
golem::run_dev()
start.time <- Sys.time()
run_model("Test", 10)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
run_model("Test", 100)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
run_model("Test", 1000)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
library(profvis)
profvis({
run_model("Test", 100)
})
sessionInfo()
golem::run_dev()
start.time <- Sys.time()
run_model("Test", 1000)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
run_model("Test", 1000)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
run_model("Test", 1000)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
run_model("Test", 1000)
golem::run_dev()
start.time <- Sys.time()
run_model("Test", 1000)
golem::run_dev()
start.time <- Sys.time()
run_model("Test", 1000)
start.time <- Sys.time()
run_model("Test", 10)
library(triangle)
start.time <- Sys.time()
run_model("Test", 10)
golem::run_dev()
library(triangle)
start.time <- Sys.time()
run_model("Test", 10)
library(triangle)
golem::run_dev()
golem::run_dev()
golem::run_dev()
library(triangle)
start.time <- Sys.time()
run_model("Test", 10)
library(profvis)
profvis({
run_model("Test", 100)
})
library(profvis)
profvis({
CEMRA::run_model("Test", 100)
})
golem::run_dev()
library(profvis)
profvis({
run_model("Test", 100)
})
golem::run_dev()
library(profvis)
profvis({
run_model("Test", 100)
})
library(profvis)
profvis({
run_model("Test", 100)
})
golem::run_dev()
library(profvis)
profvis({
run_model("Test", 100)
})
golem::run_dev()
######################
start.time <- Sys.time()
CEMRA::run_model("Test", 1000)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
golem::run_dev()
######################
start.time <- Sys.time()
CEMRA::run_model("Test", 500)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
golem::run_dev()
golem::run_dev()
golem::run_dev()
golem::run_dev()
golem::run_dev()
golem::run_dev()
golem::run_dev()
golem::run_dev()
golem::run_dev()
golem::run_dev()
golem::run_dev()
golem::run_dev()
######################
start.time <- Sys.time()
CEMRA::run_model("Test", 500)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
golem::run_dev()
golem::run_dev()
golem::run_dev()

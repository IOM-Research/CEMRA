error_gen<-function(actual, rounded){
  divisor<-ifelse(sqrt(actual)<1, 1, actual)
  results<-(rounded-actual)^2/divisor
  return(results)
}


round_to_100<-function(percents){
  n=length(percents)
  rounded<-sapply(percents, as.integer)
  
  if(sum(rounded)==100){
    return(rounded)
  }else{
    up_count<-100-sum(rounded)
  
    rounds<-data.frame(rounded)
    rounds<-cbind(rounds, percents)
    

    
    
    #errors<-NULL
    #for(i in 1:n){
    #  d<-mapply(error_gen, percents[i], rounded[i]+1) - mapply(error_gen, percents[i], rounded[i])
    #  errors<-c(errors, d)
    #}
    
    rounds<-cbind(rounds, errors)
    
    
    rank<-sort(errors)
    ################################ THIS BIT NOT WORKING #################
    for (i in 1:up_count){
      rounded[rank[i][1]]<- rounded[rank[i][1]] + 1
    return(rounded)
      ################################ THIS BIT NOT WORKING #################
      
    }
  }
}

nums<-c(0.00462, 68.2, 31.8, 0.000000165)

round_to_100(nums)



round_percent <- function(x) { 
  x <- x/sum(x)*100  # Standardize result
  res <- floor(x)    # Find integer bits
  rsum <- sum(res)   # Find out how much we are missing
  if(rsum<100) { 
    # Distribute points based on remainders and a random tie breaker
    o <- order(x%%1, sample(length(x)), decreasing=TRUE) 
    res[o[1:(100-rsum)]] <- res[o[1:(100-rsum)]]+1
  } 
  res 
}


